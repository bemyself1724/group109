# <center> SM3软件实现及优化 </center>

## 运行方式
将SM3_optimize文件目录下的工程文件SM3_optimize.sln复制到自己的项目中即可运行。


## 1.SM3代码的实现
由于本实验需要采用硬件级并行技术SIMD来加速加密过程，因此采用允许显式使用SIMD内置函数或利用编译器优化来自动矢量化操作的C++代码编写。SM3的算法结构请参考项目一的readme文件。


## 2.优化加速
从理论上讲，SM3算法中使用最多且最耗时的是消息扩展和64轮压缩函数,因此，快速实现的关键在加速这两部分。采取的优化方式有采用SIMD指令并行计算；循环展开；逻辑函数优化等。

### SIMD指令并行计算
传统的指令集架构（如标量指令集）一次只能处理一个数据元素，而SIMD指令集可以在同一时钟周期内同时处理多个数据元素，从而实现并行计算。在本实验中，采用_mm_and_si128， _mm_srli_epi32等指令，提高了并行性和处理速度，节省了指令缓存和指令解码的开销，简化了编程。


### 循环展开
在消息扩展过程中，循环内存在大量的循环移位与逻辑运算操作，如：
```C++
 for (int i = 16; i < 68; i++)
    {
        W[i] = p1(W[i - 16] ^ W[i - 9] ^ (loop_left(W[i - 3], 15))) ^ loop_left(W[i - 13], 7) ^ W[i - 6];

    }

```
因此，可以借助SIMD指令进行循环展开，步幅为4，内部使用SIMD指令进行并行计算，一次进行4个扩展块的生成，减少了消息扩展快加载和存储次数，提高了消息扩展的速度。
```C++
 for (int j = 4; j < 17; j++)
    {
        W[j * 4] = p1(W[j * 4 - 16] ^ W[j * 4 - 9] ^ (loop_left(W[j * 4 - 3], 15))) ^ loop_left(W[j * 4 - 13], 7) ^ W[j * 4 - 6];
        w16 = _mm_setr_epi32(W[j * 4 - 16], W[j * 4 - 15], W[j * 4 - 14], W[j * 4 - 13]);  //w0||w1||w2||w3
        w13 = _mm_setr_epi32(W[j * 4 - 13], W[j * 4 - 12], W[j * 4 - 11], W[j * 4 - 10]);
        w9 = _mm_setr_epi32(W[j * 4 - 9], W[j * 4 - 8], W[j * 4 - 7], W[j * 4 - 6]);    //w8||...||w11
        w6 = _mm_setr_epi32(W[j * 4 - 6], W[j * 4 - 5], W[j * 4 - 4], W[j * 4 - 3]);
        w3 = _mm_setr_epi32(W[j * 4 - 3], W[j * 4 - 2], W[j * 4 - 1], W[j * 4]);
        w16_or_w9 = _mm_xor_si128(w16, w9);       //W[i - 16] ^ W[i - 9]
        LL15_w3 = left_simd(w3, 15);              //loop_left(W[i - 3], 15)
        LL7_w13 = left_simd(w13, 7);              //loop_left(W[i - 13], 7)
        w16_or_w9_or_LL15_w3 = _mm_xor_si128(w16_or_w9, LL15_w3);    //(W[i - 16] ^ W[i - 9] ^ (loop_left(W[i - 3], 15))
        LL7_w13_or_w6 = _mm_xor_si128(LL7_w13, w6);       //loop_left(W[i - 13], 7) ^ W[i - 6]
        P = P1_simd(w16_or_w9_or_LL15_w3);
        re = _mm_xor_si128(P, LL7_w13_or_w6);
        memcpy(&W[j * 4], (int*)&re, 16);         //进行4个W[]的填充
    }

```
注：
* 1.理论上可以进一步通过增加数组存储进行步幅为8的循环展开，出现了编译器溢出的问题未能解决。
* 2.采用类似思路：迭代压缩过程中每一个消息块需要进行 64 轮迭代，每轮迭代处理一组输入。由于相邻轮迭代的输入之间没有依赖关系，所以可以通过复制一组处理逻辑，在每轮迭代中处理两组输入，在一个周期内串行地完成两轮压缩函数，将一个消息块的迭代周期降到 32 个，从而提升吞吐量。

### 逻辑函数优化
由于SM3算法存在很多逻辑操作，例如P1函数，循环左移函数等。可以借助SIMD指令使得逻辑函数内部可并行计算中间数值,如：
```C++
__m128i left_simd(__m128i a, int k)
{
    k = k % 32;
    __m128i tmp1, tmp2, tmp3, tmp4;
    __m128i zhengshu = _mm_set_epi32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);  //定义一个128位整数，其所有位均为1
    tmp2 = _mm_and_si128(zhengshu, _mm_slli_epi32(a, k));   //将a向左移动 k 位，并将结果与整数进行按位与操作，将多余的位清零
    tmp3 = _mm_srli_epi32(_mm_and_si128(zhengshu, a), 32 - k);  //将 a 向右移动 32 - k 位，并将结果与整数进行按位与操作，将多余的位清零
    tmp4 = _mm_or_si128(tmp2, tmp3);
    return tmp4;
}
```
此外，本实验还采用了预计算必要常数值，优化数组结构提高命中率等角度提高了加密速度。

## 3.运行结果

![](https://pic.imgdb.cn/item/64cb38431ddac507cc4095c9.jpg)

可以看到，加密相同数据采取上述步骤优化后大概有12.5%左右的效率提升。


##  引文参考
[1]https://zhuanlan.zhihu.com/p/55327037

[2]http://eprint.iacr.org/2012/067.pdf

[3]https://zhuanlan.zhihu.com/p/391091872
